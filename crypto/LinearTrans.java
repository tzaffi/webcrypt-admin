package webcrypt.crypto;

/** 
 * The LinearTrans Kernel is an alphabetic block cipher of arbitrary sized 
 * (but not too big because of the slow alogorithm used for matrix inversion) 
 * text blocks.  Blocks of letters are considered to be base-26 vectors
 * thus the block
 *
 *     BAMBA = (1,0,12,1,0) (mod 26)
 * 
 * The key is a text-generated mod-26 matrix M which induces a linear
 * transformation on each plaintext block P according to the rule of Matrix
 * multiplication
 * 
 *     C = B*M
 *
 * The key of type LinearTransKey is generated by a string of the form
 * 
 *     dim_keyword
 *
 * where dim is an integer giving the matrix dimensions (dim > 5 is not
 * recommended due to the slow inversion algorithm), and keyword is an
 * alphabetic text recommended to be of length >= dim^2.  If the text
 * is shorter than dim^2, letters are added up to length dim^2 by 
 * starting the alphabet progression from the last included letter.
 * For example the keyword
 *
 *     5_ZEPH
 *
 * Induces dim = 5 and keyword = ZEPHIJKLMNOPQRSTUVWXYZABC
 *
 * The keyword is then converted to an base-26 array which fill the matrix
 * M column, by column starting on the left.  In the example above our
 * keyword-array is 
 *   (25,4,15,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,1,2)
 *
 * and M is filled in as
 *
 *        / 25  9 14 19 24 \
 *        |  4 10 15 20 25 |
 *   M =  | 15 11 16 21  0 |
 *        |  7 12 17 22  1 |
 *        \  8 13 18 23  2 /
 *
 * Because in this instance the keyword was too short, the last 4 columns
 * are linearly dependent and the determinant is 0. 
 *
 * When a singular matrix is generated, a KeyCreationException is thrown
 * asking the user to change the passphrase.  If the passphrase is sufficiently
 * long, there is a > 40% chance that a passphrase will result in a non-singular
 * matrix and so a small change should create a non-singular matrix.
 *
 * This cryptographic method is pedagogic only and is easy to break with
 * a known plaintext attack.
 *
 * @author <a href="mailto:zeph@cs.columbia.edu">Zeph Grunschlag</a>
 */
import webcrypt.math.*;  // for David Bishop's ModMatrix associated classes (modified)
import webcrypt.character.CharDomains;

public class LinearTrans extends Kernel{
    
    /**
     * Currently the domain are capitals and modulus is 26.
     * Change this constant and the constructor to generalize.
     */
    public final static int MODULUS = 26;

    public String toString(){
	return "LinearTrans(dim_keyword)"; 
    }

    public LinearTrans(){
	setDomain(LETTERS);
	setAssociatedKeyClass("webcrypt.crypto.LinearTransKey");
    }

    /**
     * Encrypt the parameter plaintext and mutate it to the ciphertext
     * using the key e.
     *
     * Non-letters are ignored, but the text is capitalized.  Blocks are formed
     * by grouping together sequences of letters, possibly separated by non-letters.
     * For example if the block size is 4 and the plaintext is
     *   h37ll%o d&(lly
     * the the blocks considered for encryption are hllo, dlly
     *
     * Break the plaintext into blocks P of size blockSize, view as vectors
     * mod-26, and then multiply by the key M according to the rule C = M*P
     * to obtain cipher text blocks C.  Pad with Z's the last block to get to
     * the correct size.
     */
    public void encryptOn(StringBuffer plaintext, Key e){
	LinearTransKey k = (LinearTransKey)e;
	setBlockSize(k.getBlockSize());
	ModSquareMatrix M = k.getMatrix();
	int len = plaintext.length();
	int b = getBlockSize();
	int idx = 0;
	String plainstr = plaintext.toString().toUpperCase();

	// go thru string finding blocks and replacing in buffer after encrypting
	int[] offsets;
	String block;
	int[] blockarray = new int[b];
	ModMatrix P; // the plaintext block as a column vector
	while( idx < len ){
	    //first find the next block
	    offsets = findBlockOffsets(plainstr,idx,b);
	    block = "";
	    for(int i=0; i<b; i++){
		if( offsets[i] != -1)
		    block += plainstr.charAt(idx+offsets[i]);
		else // need to pad
		    block += 'Z';
	    }
	    
	    //transform the block to an int array...
	    for(int i=0; i<b; i++) blockarray[i] = (int)(block.charAt(i)-'A');
	    //...and then to a matrix
	    P = new ModMatrix(b,1,blockarray,26);

	    //encrypt:
	    try{
		P = M.multiply(P);
	    }catch(MatricesNonConformableException mnce){
		System.out.println("THIS SHOULD NEVER HAPPEN!!!!");
	    }

	    //get the enciphered block:
	    block = "";
	    for(int i=1; i<=b; i++) {
		//		System.out.println(P.getElement(i,1));
		block += ( (char)('A'+P.getElement(i,1).intValue() ) );
	    }

	    //replace the block in the string buffer according to offsets
	    for(int i=0; i<b; i++){
		if( offsets[i] != -1)
		    plaintext.setCharAt(idx+offsets[i],block.charAt(i));
		else 
		    plaintext.append(block.charAt(i));
	    }	    

	    //move cursor:
	    if (offsets[b-1] == -1) //at the end
		idx = len;
	    else // move cursor right past last offset
		idx += offsets[b-1]+1; 
	}
    }

    /**
     * Decrypt the parameter ciphertext and mutate it back to the plaintext
     * using the key d.
     *
     * Just reverse the key d and encrypt.
     */
    public void decryptOn(StringBuffer ciphertext, Key d){
	encryptOn(ciphertext,d.reverseKey());
    }

    /**
     * Main method for testing purposes.
     */
    public static void main(String[] args) throws KeyCreationException{
	System.out.println("About the key...\n");
	LinearTransKey e = new LinearTransKey("3_alterably");
	System.out.println("e.seedKey = "+e.getSeedKey());
	System.out.println("e.blockSize = "+e.getBlockSize());
	System.out.println("e.EffectiveKeyStr = "+e.getEffectiveKeystr());
	System.out.println("e.array = ");
	for(int i=0; i<e.getArray().length; i++) System.out.print(e.getArray()[i]+",");
	System.out.println("\ne.matrix = ");
	e.getMatrix().display();
	System.out.println("determinant = "+e.getMatrix().det());
	System.out.println("\n\nNow invert e.");
	LinearTransKey d = (LinearTransKey)e.reverseKey();
	d.getMatrix().display();
	System.out.println("determinant = "+d.getMatrix().det());
	
	System.out.println("\n\n\nAnd now for some encryption and decryption...\n");
	LinearTrans ker = new LinearTrans();
	StringBuffer buf;
	for(int i=0; i<args.length; i++){
	    buf = new StringBuffer(args[i]);
	    System.out.println("plaintext  =  "+buf);
	    ker.encryptOn(buf,e);
	    System.out.println("ciphertext =  "+buf);
	    ker.decryptOn(buf,e);
	    System.out.println("plaintext? -->"+buf);
	}
    }
}
