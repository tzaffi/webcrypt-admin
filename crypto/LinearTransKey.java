package webcrypt.crypto;

/** 
 * Key class associated with the LinearTrans cryptographic Kernel.
 * The key is an nxn mod-26 matrix generated by a key word as follows:
 * The mod-26 matrix M is generated by a string of the form
 * 
 *     dim_keyword
 *
 * where dim is an integer giving the matrix dimensions (dim > 5 is not
 * recommended due to the slow inversion algorithm), and keyword is an
 * alphabetic text recommended to be of length >= dim^2.  If the text
 * is shorter than dim^2, letters are added up to length dim^2 by 
 * starting the alphabet progression from the last included letter.
 * For example the keyword
 *
 *     5_ZEPH
 *
 * Induces dim = 5 and keyword = ZEPHIJKLMNOPQRSTUVWXYZABC
 *
 * The keyword is then converted to an base-26 array which fill the matrix
 * M column, by column starting on the left.  In the example above our
 * keyword-array is 
 *   (25,4,15,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,1,2)
 *
 * and M is filled in as
 *
 *        / 25  9 14 19 24 \
 *        |  4 10 15 20 25 |
 *   M =  | 15 11 16 21  0 |
 *        |  7 12 17 22  1 |
 *        \  8 13 18 23  2 /
 *
 * Because in this instance the keyword was too short, the last 4 columns
 * are linearly dependent and the determinant is 0. 
 *
 * When a singular matrix is generated, a KeyCreationException is thrown
 * asking the user to change the passphrase.  If the passphrase is sufficiently
 * long, there is a > 40% chance that a passphrase will result in a non-singular 
 * matrix and so a small change should create a non-singular matrix.
 *
 * @author <a href="mailto:zeph@cs.columbia.edu">Zeph Grunschlag</a>
 */
import webcrypt.math.*;   // for David Bishop's ModMatrix associated classes (modified)
import webcrypt.io.*;     // for filtering through a file of words to find good keywords
import java.util.StringTokenizer;
import java.math.BigInteger;


public class LinearTransKey extends Key{
    /**
     * The block size
     */
    private int blockSize;

    /**
     * The part of the key that generates the matrix, after 
     * capitalizing, removing non-alphabetic characters, 
     * and pruning or adding to get length blockSize^2
     */
    private String effectiveKeystr;

    /**
     * The internal representation of the key as an array
     */
    private int[] arrayKey;
    
    /**
     * The internal representation of the key as a matrix,
     * i.e.
     */
    private ModSquareMatrix  matrixKey;

    /**
     * Useful to have the determinant of the matrix around
     * to avoid recalcluation
     */
    private BigInteger det;

    /**
     * Accessor method for blockSize
     */
    public int getBlockSize(){ return blockSize; }

    /**
     * Accessor method for effective key
     */
    public String getEffectiveKeystr(){ return effectiveKeystr; }

    /**
     * Accessor method for arrayKey
     */
    public int[] getArray(){ return arrayKey; }

    /**
     * Accessor method for matrixKey
     */
    public ModSquareMatrix getMatrix(){ return matrixKey; }

    /**
     * Accessor method for determinant
     */
    public BigInteger getDeterminant(){ return det; }

    private String errstr = "Key text must be of the form \"dim_keyphrase\"\n"
	+ "with dim a small positive integer,\n"
	+ "and keyphrase an alphabetic string of length near dim^2.";

    /**
     * Create the effective key as explained in the top comments.
     */
    public LinearTransKey(String keytext) throws KeyCreationException{
	super(keytext);
	if (keytext == null) keytext = "";
	seedKey = keytext;
	StringTokenizer keytokens = new StringTokenizer(keytext,"_");
	if (keytokens.countTokens() < 2)
	    throw new KeyCreationException(errstr);
	try{
	    blockSize = Integer.parseInt(keytokens.nextToken());
	}catch(NumberFormatException e){
	    throw new KeyCreationException(errstr);
	}
	if (blockSize < 1) 	    
	    throw new KeyCreationException(errstr);
	// So blockSize is okay now!

	// Prune out non-letters and pad to get appropriate length
	effectiveKeystr = makeEffectiveKeystr(seedKey,blockSize);
	
	// Convert to integer array
	// This is done in a non obvious way in order to
	// get slightly less obvious linear transformations
	// by permuting the row elements
	// For example, the key string "THEBEACHESONMAUI"
	// would give a matrix:
	// T E E M
	// H A S A
	// E C O U
	// B H N I
	// so that the generated array would look like
	// (T,E,E,M,H,A,S,A,E,C,O,U,B,H,N,I)
	arrayKey = new int[blockSize * blockSize];
	for(int i = 0; i < blockSize; i++) // for each row
	    for(int j = 0; j < blockSize; j++) // for each col
		arrayKey[i + blockSize*j] 
		    = (int)(effectiveKeystr.charAt(blockSize*i+j)-'A');
	
	// Create matrix key
	matrixKey = new ModSquareMatrix(blockSize,arrayKey,LinearTrans.MODULUS);

	// Finally, test that it is invertible and if not throw exception
	det = matrixKey.det();

	if (!ModSquareMatrix.isInvertibleModulo(det,LinearTrans.MODULUS))
	    throw new KeyCreationException("Unfortunately, your key phrase did not\n"+
					    "result in an decryptable algorithm.\n"+
					    "Try increasing the length of your phrase\n"+
					    "or making slight changes.\n"+
					    det+" isn't invertible modulo "+LinearTrans.MODULUS);
    }

    /**
     * Helper method for constructor, making the effective key string.
     * The result is a String of length dim^2.
     * For example if dim = 4, and in = "mercury@noon15" the key would
     * be transformed as follows:
     * 0. mercury@noon15
     * 1. MERCURYNOON
     * 2. MERCURYNOONOPQRW (length 16)
     */
    public static String makeEffectiveKeystr(String in, int dim){
	//capitalize
	in = in.toUpperCase();
	
	//remove non-letters keeping only first dim^2 letters
	String out = "";
	int j=0; //index four out
	for(int i=0; i<in.length() && j < dim*dim; i++){
	    char c = in.charAt(i);
	    if (Character.isLetter(c)){
		out += c;
		j++;
	    }
	}

	//if no letters (very bad) reset out = "q"
	if (out.equals("")){
	    out = "q";
	    j = 1;
	}

	//Now complete the keyword up to length dim^2
	for( ; j < dim*dim; j++){
	    char lastletter = out.charAt(j-1);
	    int val = (int)(lastletter - 'A') + 1;
	    val %= LinearTrans.MODULUS;
	    out += (char)(val+(int)'A');
	}
	return out;
    }

   public Object clone(){  
	Object x = null;
	try{
	    x = new LinearTransKey(seedKey); 
	}catch(KeyCreationException e){
	    // can't happen since key already got created
	}
	return x;
    }
    
    
    /**
     * To reverse the key, one must invert the matrix
     */
    public Key reverseKey(){
	LinearTransKey k = (LinearTransKey)clone();
	try{
	    k.matrixKey = matrixKey.slowInverse();
	}catch(SingularMatrixException e){
	    System.out.println("THIS CAN'T HAPPEN BECAUSE OF CAREFUL CONSTRUCTOR!");
	}
	k.setReverseKey(true);
	return k;
    }

    /**
     * Look through a file of words for all words which generate valid keys.
     * Print the results out in another file.
     */
    public static void FilterGoodKeys(String filename, int blockSize){
	String words = TextManip.getWholeFile(filename);
	StringTokenizer wordTokens = new StringTokenizer(words);
	System.out.println("Number of words: "+wordTokens.countTokens());
	
	LinearTransKey k = null;
	StringBuffer outbuff = new StringBuffer("");
	int cnt = 0;
	// assuming that at least one token...
	do{
	    try{
		k = new LinearTransKey(""+blockSize+"_"+wordTokens.nextToken());
		outbuff.append(k.getSeedKey()+"\n");
		cnt++;
	    }
	    catch(KeyCreationException e){
		//do nothing 
	    }
	}while(wordTokens.hasMoreTokens());
	System.out.println("Number of accepted words: "+cnt);
	String outfilename = (new StringTokenizer(filename,".")).nextToken()+"_filtered.txt";
	System.out.println("Saving to file "+outfilename);
	SaveFile.write(new java.io.File(outfilename),""+outbuff);
    }

    /**
     * Main method for testing constructor and finding good keywords.
     * 
     * USAGE:
     *>java webcrypt.crypto.LinearTransKey testword filename blocksize
     */
    public static void main(String[] args){
	try{
	    LinearTransKey k = new LinearTransKey(args[0]);
	    System.out.println("k.seedKey = "+k.getSeedKey());
	    System.out.println("k.blockSize = "+k.getBlockSize());
	    System.out.println("k.EffectiveKeyStr = "+k.getEffectiveKeystr());
	    System.out.println("k.array = ");
	    for(int i=0; i<k.getArray().length; i++) System.out.print(k.getArray()[i]+",");
	    System.out.println("\nk.matrix = ");
	    k.getMatrix().display();
	    System.out.println("determinant = "+k.getMatrix().det());
	    System.out.println("\n\nNow invert k.");
	    k = (LinearTransKey)k.reverseKey();
	    k.getMatrix().display();
	    System.out.println("determinant = "+k.getMatrix().det());
	}catch(KeyCreationException e){
	    System.out.println(""+e);
	}
	System.out.println("Searching for keywords through "+args[args.length-2]);
	FilterGoodKeys(args[args.length-2],Integer.parseInt(args[args.length-1]));
    }
}
