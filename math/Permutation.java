package webcrypt.math;

/**
 * A class that allows for easy permuations of sets 
 * of characters.  A permutation is generated by
 * specifying the ordered set of outputs:
 * 
 * E.G. the mathematical notation for the permutation
 * (1320) which means 1 --> 3, 3 --> 2, 2 --> 0, 0 --> 1
 * could also be described by the correspondence:
 * (0,1,2,3) |---> (1,3,0,2)
 * and in our scheme this would be represented by (1,3,0,2)
 * Thus, the constructor of this permuation (if the domain
 * is correct) would have the parameter {1,3,0,2}.
 *
 * @author <a href="mailto:zeph@cs.columbia.edu">Zeph Grunschlag</a>
 */
public abstract class Permutation{

    // Set the domain size which is static since for each encryption algorithm
    // the domain size is fixed.  E.G. for capitals, the size is 26
    protected static int domainSize;

    /**
    * Get the domain size which is static since for each encryption algorithm
    * the domain size is fixed.  E.G. for capitals, the size is 26
    */
    public static int getDomainSize(){ return domainSize; }
    
    /**
    * The domain is a set of characters.
    * We have elected to allow an arbitrary set (and not just
    * a range) for maximal flexibility, though we sacrifice
    * efficiency both in time and space.
    */
    protected static char[] domain;

    public static char[] getDomain() { return domain; }


    // The permuations is just a function given by an array
    // with the property that every possible index appears as an element.
    protected int[] perm;

    /**
     * The numerical version of the permutation is publicly available:
     * No check has been made to avoid ArrayIndexOutOfBoundsExeption's
     * which would occur if an invalid input is given.  This is upto
     * the user to ensure.
     */
    public int permute(int input){ return perm[input]; }

    /**
     * The char version of the permutation:
     * This is slow since, unless the char2idx function is 
     * over-ridden with a faster hash-table based method.
     * If the character is not in the domain it is returned
     * as-is
     */
    public char permute(char input){
	int idx = char2idx(input);
	return( idx==-1 ? input : domain[permute(idx)] );
    }

    /**
     * Find the index of the given char.  -1 is returned if character
     * not present.
     * Theoretically faster methods are possible using hash-tables
     * but for the small examples anticipated being used, this would
     * be overkill.  If you are considering encrypting large tracts,
     * override this method.
     */
    public int char2idx(char c){
	int i;
	for(i = 0; i < domainSize; i++)
	    if (c == domain[i])
		break;
	if (i==domainSize) return -1;
	return i;
    }

    /**
     * Invert the permuation.  Only the perm[] needs to be changed 
     * as the domain is fixed.
     */
    public void invert(){
	perm = inverseArray();
    }

    /**
     * Conmpute the array for the inverse permutation:
     */
    public int[] inverseArray(){
	int[] inverse = new int[domainSize];
	for(int i=0; i<domainSize; i++)
	    inverse[perm[i]] = i;
	return inverse;
    }
	  

    /**
     * Create a permutation by specifying a permutation
     * using an array
     **/
    public Permutation(int[] outputarray) throws IllegalPermutationException{
	if( !validRange(outputarray) )
	    throw new IllegalPermutationException("Invalid input array.");
	perm = outputarray;
    }

    /**
     * Helper method for the previous constructor
     */
    public boolean validRange(int[] outputarray){
	if ( outputarray.length != domainSize )
	    return false; // domain and range of different sizes
	int[] counter = new int[domainSize]; // all 0's automatically
	for(int i=0; i < domainSize; i++){
	    int val = outputarray[i];
	    // if out-of range, or value already encountered
	    if (val < 0 || val >= domainSize || counter[val]++ > 0)
		return false;
	    // no need to check that all values hit since one-to-one
	    // implies onto!!!
	}
	return true;
    }
    
    /**
     * Useful for inspecting permutations:
     */
    public String toString(){
	String part1 = "Numerical: (";
	String part2 = "Alphabet:   ";
	for(int i=0; i < domainSize; i++){
	    part1 += (i==0?"":",")+perm[i];
	    part2 += permute(domain[i]);
	}
	part1 += ")";
	return (part1+'\n'+part2);
    }

    //    public static void main(String[] args) throws IllegalPermutationException{    }
}
    



